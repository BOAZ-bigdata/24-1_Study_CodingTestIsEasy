# [권준혁]

### 문제
N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.

어느 날 이 N명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다. 이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다.

각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다. 하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다.

이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다. N명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생은 누구일지 구하여라.

### 입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), X가 공백으로 구분되어 입력된다. 두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다. 시작점과 끝점이 같은 도로는 없으며, 시작점과 한 도시 A에서 다른 도시 B로 가는 도로의 개수는 최대 1개이다.

모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.

### 출력
첫 번째 줄에 N명의 학생들 중 오고 가는데 가장 오래 걸리는 학생의 소요시간을 출력한다.

## 접근법 (생각의 흐름 설명)
요구사항에서의 주요 조건:  
1. M개의 단방향 도로별 Ti 시간 소비 -> 가중치가 있는 단방향 그래프가 주어짐.  
2. 최단 시간 구하기 -> 최단 시간 알고리즘은 가중치 유무에 따라 DFS/BFS vs 다익스트라  
3. 오고 가는 시간 구하기 -> 출발점에서 목적지까지 이동 후, 목적지에서 출발점으로 다시 복귀하는 경로를 탐색  
    - 출발점 -> 목적지, 목적지 -> 출발점 각각의 경로가 서로 다를 수 있다.  

위의 요소들을 고려하니, 이는 가중치가 있는 단방향/양방향 그래프에서의 최단 경로를 구하는 다익스트라 알고리즘이 적합하다고 판단했다.  

## 상세한 해설
다익스트라 알고리즘은 출발점이 입력으로 주어졌을 때, 나머지 모든 노드로 도달하는 데에 소요되는 최단 경로를 Greedy 논리로 구하는 알고리즘이다.  

주어진 문제는 출발점에서 도착점까지 가는 것뿐만 아니라, 도착점에서 출발해서 출발점까지 가는 경로까지 고려해서 최단 경로를 구해야 한다.   
따라서 모든 노드를 출발점으로 설정해서, 각각에 대해 다익스트라 알고리즘을 수행해야 한다.  
```python
dis = [[INF] * N for _ in range(N)]
```
모든 노드 각각을 출발점으로 설정하고 최단경로를 저장해야해서 2차원 배열을 선언했다.  
메모리 초과는 발생하지 않는 이유는 공간복잡도가 O(N^2) = 100먼이므로 메모리가 충분했기 때문이다.  

```python
def dijkstra(st):
    global dis, G
    q = []
    heapq.heappush(q, (0, st))
    dis[st][st] = 0
    
    while(q):
        w, now = heapq.heappop(q)
        if dis[st][now] < w: # 이미 방문했기에 다시 방문 안함.
            continue
        for nw, nxt in G[now]:
            if dis[st][nxt] > w + nw:
                dis[st][nxt] = w + nw
                heapq.heappush(q, (w + nw, nxt))
```
따라서 위 코드에서와 같이 입력 st를 입력으로 최단 경로를 dis[st]에 저장했다.  
위 문제에서 heapq를 활용하는 이유는, 다익스트라 알고리즘은 그래프 탐색 시에 매 순간마다 지금까지 구한 최단경로를 활용해서 다음 노드를 탐색하기 때문이다.  

heapq 없이 구현할 경우 지금까지 구한 최단경로 상 다음에 탐색할 노드를 찾을 때 모든 노드에 대해 확인해야 하기 때문에 O(N)의 시간복잡도 소요되기 때문이다. 여기서 N은 그래프의 모든 노드의 개수이다.  
이를 heapq를 이용해서 구할 경우 이진 트리를 활용해서 가장 작은 값을 저장하는 0번째 노드인 부모 노드를 반환하고 다시 heap 구조로 변환해서 O(logN)의 시간복잡도만 소요 된다.  
물론 O(N)으로 충분히 가능할 수 있지만, 본 문제에서는 N=10^3이고 모든 노드를 확인해야 하므로 최악의 경우 O(N^3) = 10억의 연산이 요구되므로 시간 초과가 발생한다.  
따라서 heapq를 사용해야 한다.  

```python
    for i in range(0, N):
        dijkstra(i)
```
위와 같이 모든 정점에 대해 방문한다.

```python
    res = [0] * len(dis)
    
    for i in range(0, N):
        res[i] = dis[i][X - 1] + dis[X - 1][i]
    print(max(res))
```
위와 같이 모든 정점에 대해 오고 가는 최단 경로를 모두 구해서 최대값을 출력했다.  

## 회고
나의 소요시간은 1024ms였는데, 100ms 미만으로 푼 풀이들도 있었다.  
해당 풀이는 모든 정점에 대한 최단경로를 구하지 않고 도착점 X가 출발점이 되도록 하는 그래프를 추가로 만들어서 돌아가는 최단 경로를 구할 수 있게 했다.  
즉 시간 복잡도가 내 풀이는 O(N * N * logN)이었는데, O(N * logN)으로 획기적으로 줄이는 풀이인 것이다.  
굉장히 좋은 아이디어이고, 곧 해당 풀이로 다시 풀어서 업로드하고자 한다.

## Solution

<!--전체 코드 첨부-->

```python
import sys
input = sys.stdin.readline
from collections import defaultdict
import heapq
INF = 10 ** 7 # max 100만

def dijkstra(st):
    '''
    get_small(a, visited)를 heapq 없이 구현할 경우: (G[nxt] 제외)
    총 시간복잡도 = O(N * N * N) = 10^(3*3) = 10^9 = 10억 -> 시간 초과
    총 시간복잡도 = O(N * N * logN) = 10^7 = 천만 -> 가능
    '''
    global dis, G
    q = [(0, st)]
    dis[st][st] = 0
    
    while(q):
        w, now = heapq.heappop(q)
        if dis[st][now] < w: # 이미 방문했기에 다시 방문 안함.
            continue
        for nw, nxt in G[now]:
            if dis[st][nxt] > w + nw:
                dis[st][nxt] = w + nw
                heapq.heappush(q, (w + nw, nxt))

if __name__ == '__main__':
    N, M, X = map(int, input().split())
    G = defaultdict(list)
    
    for _ in range(M):
        a, b, c = map(int, input().split())
        G[a - 1].append((c, b - 1))
    dis = [[INF] * N for _ in range(N)] # 10^6 = 100만 -> 메모리 충분, i->j
    
    for i in range(0, N):
        dijkstra(i)
    
    res = [0] * len(dis)
    
    for i in range(0, N):
        res[i] = dis[i][X - 1] + dis[X - 1][i]
    print(max(res))
```