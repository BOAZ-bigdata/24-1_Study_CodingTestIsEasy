# Index

+ [권준혁](#권준혁)
+ [안지완](#안지완)
+ [오효근](#오효근)
+ [조은학](#조은학)

---

# [최소 스패닝 트리](https://www.acmicpc.net/problem/1197)

그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.

최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.

## 입력

첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.

그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.

## 출력

첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.

## 예제

> 입력 1

```
3 3
1 2 1
2 3 2
1 3 3
```

> 출력 1

```
3
```

---

# [권준혁](https://github.com/tree-jhk)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [안지완](https://github.com/synoti21)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [오효근](https://github.com/Zerohertz)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [조은학](https://github.com/choeunhak)

## 접근법 (생각의 흐름 설명)
<!--문제를 풀며 생각의 흐름을 글로 작성-->
최소 스패닝 트리를 만들면 되겠구나
바로 find union 함수 구현할 생각을 하였음
크루스칼!

## 상세한 해설
<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->
### find(node, parent)
- 주어진 노드 node의 루트 노드를 찾는 함수
- 재귀적으로 부모 노드를 따라가며 루트 노드를 찾음
- 이때 부모 노드를 갱신하여 경로 압축(Path Compression) 수행 
- 경로 압축은 루트를 찾은 후에 해당 루트를 바로 가리키도록 부모 노드를 갱신하는 기법

### union(x, y, parent): 
- 주어진 두 노드 x와 y를 포함하는 두 트리를 합치는 함수
- 이 함수는 두 노드의 루트를 찾은 후에 하나의 루트를 다른 루트의 자식으로 설정하여 두 트리를 합침

### main(): 
- 메인 함수는 입력을 받고, 간선들을 가중치에 따라 정렬한 뒤 Kruskal 알고리즘을 이용하여 최소 스패닝 트리의 가중치 합을 계산하고 출력


## 회고
<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->
일반적인 최소 신장 트리는 union find 함수를 잘 구현한 다음에 그래프를 잘 돌리면 되는 것 같당

## Solution
<!--전체 코드 첨부-->

```python
import sys

def find(node, parent):
    if node != parent[node]:
        parent[node] = find(parent[node], parent)
    return parent[node]

def union(x, y, parent):
    x_root = find(x, parent)
    y_root = find(y, parent)
    parent[y_root] = x_root

def main():
    v, e = map(int, sys.stdin.readline().split())
    edges = [list(map(int, sys.stdin.readline().split())) for _ in range(e)]
    edges.sort(key=lambda x: x[2])
    parent = list(range(v + 1))
    total_weight = 0

    for start, end, weight in edges:
        if find(start, parent) != find(end, parent):
            union(start, end, parent)
            total_weight += weight

    print(total_weight)

if __name__ == "__main__":
    main()
```
