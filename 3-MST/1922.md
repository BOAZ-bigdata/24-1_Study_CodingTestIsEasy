# Index

+ [조은학](#조은학)

---

# [네트워크 연결](https://www.acmicpc.net/problem/1922)

도현이는 컴퓨터와 컴퓨터를 모두 연결하는 네트워크를 구축하려 한다. 하지만 아쉽게도 허브가 있지 않아 컴퓨터와 컴퓨터를 직접 연결하여야 한다. 그런데 모두가 자료를 공유하기 위해서는 모든 컴퓨터가 연결이 되어 있어야 한다. (a와 b가 연결이 되어 있다는 말은 a에서 b로의 경로가 존재한다는 것을 의미한다. a에서 b를 연결하는 선이 있고, b와 c를 연결하는 선이 있으면 a와 c는 연결이 되어 있다.)

그런데 이왕이면 컴퓨터를 연결하는 비용을 최소로 하여야 컴퓨터를 연결하는 비용 외에 다른 곳에 돈을 더 쓸 수 있을 것이다. 이제 각 컴퓨터를 연결하는데 필요한 비용이 주어졌을 때 모든 컴퓨터를 연결하는데 필요한 최소비용을 출력하라. 모든 컴퓨터를 연결할 수 없는 경우는 없다.

## 입력

첫째 줄에 컴퓨터의 수 N (1 ≤ N ≤ 1000)가 주어진다.

둘째 줄에는 연결할 수 있는 선의 수 M (1 ≤ M ≤ 100,000)가 주어진다.

셋째 줄부터 M+2번째 줄까지 총 M개의 줄에 각 컴퓨터를 연결하는데 드는 비용이 주어진다. 이 비용의 정보는 세 개의 정수로 주어지는데, 만약에 a b c 가 주어져 있다고 하면 a컴퓨터와 b컴퓨터를 연결하는데 비용이 c (1 ≤ c ≤ 10,000) 만큼 든다는 것을 의미한다. a와 b는 같을 수도 있다.

## 출력

모든 컴퓨터를 연결하는데 필요한 최소비용을 첫째 줄에 출력한다.

## 예제

> 입력 1

```
6
9
1 2 5
1 3 4
2 3 2
2 4 7
3 4 6
3 5 11
4 5 3
4 6 8
5 6 8
```

> 출력 1

```
23
```

---

# [조은학]

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->
1197 문제와 같은 최소 스패닝 트리를 만들면 되는 문제이다!
최소 비용을 출력하기 위해서 mst 사용!


## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

### find(node)
- 노드 node의 부모 노드를 찾는 함수
- 경로 압축(Path Compression)을 통해 부모를 찾으면서 경로를 짧게 만듬

### union(x, y)
- 두 노드 x와 y를 연결하는 함수
- 두 노드의 부모를 찾고, 한 노드의 부모를 다른 노드의 부모로 설정

### mainl
주요 로직:

- 입력을 받고, 입력받은 간선을 거리(distance)에 따라 오름차순으로 정렬
- 모든 간선에 대해, 해당 간선의 양 끝점이 서로 같은 부모를 가지지 않는다면(즉, 사이클을 형성하지 않는다면), 두 노드를 연결하고 해당 간선의 거리를 최소 신장 트리의 가중치에 더함

## 회고
일반적인 최소 신장 트리는 union find 함수를 잘 구현한 다음에 그래프를 잘 돌리면 되는 것 같당
<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python
import sys

def find(node):
    if node == parent[node]:
        return node
    parent[node] = find(parent[node])
    return parent[node]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    parent[root_y] = root_x

if __name__ == "__main__":
    input = sys.stdin.readline

    n = int(input())
    m = int(input())
    edges = []
    parent = [i for i in range(n + 1)]
    total_weight = 0

    for _ in range(m):
        x, y, z = map(int, input().split())
        edges.append((z, x, y))

    edges.sort()

    for distance, x, y in edges:
        if find(x) != find(y):
            union(x, y)
            total_weight += distance

    print(total_weight)
```
