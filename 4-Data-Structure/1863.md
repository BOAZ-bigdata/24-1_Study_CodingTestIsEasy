# Index

+ [권준혁](#권준혁)
+ [안지완](#안지완)
+ [오효근](#오효근)
+ [조은학](#조은학)

---

# [스카이라인 쉬운거](https://www.acmicpc.net/problem/1863)

도시에서 태양이 질 때에 보이는 건물들의 윤곽을 스카이라인이라고 한다. 스카이라인만을 보고서 도시에 세워진 건물이 몇 채인지 알아 낼 수 있을까? 건물은 모두 직사각형 모양으로 밋밋하게 생겼다고 가정한다.

정확히 건물이 몇 개 있는지 알아내는 것은 대부분의 경우에 불가능하고, 건물이 최소한 몇 채 인지 알아내는 것은 가능해 보인다. 이를 알아내는 프로그램을 작성해 보자.

## 입력

첫째 줄에 n이 주어진다. (1 ≤ n ≤ 50,000) 다음 n개의 줄에는 왼쪽부터 스카이라인을 보아 갈 때 스카이라인의 고도가 바뀌는 지점의 좌표 x와 y가 주어진다. (1 ≤ x ≤ 1,000,000. 0 ≤ y ≤ 500,000) 첫 번째 지점의 x좌표는 항상 1이다.

## 출력

첫 줄에 최소 건물 개수를 출력한다.

## 예제

> 입력 1

```
10
1 1
2 2
5 1
6 3
8 1
11 0
15 2
17 3
20 2
22 1
```

> 출력 1

```
6
```

---

# [권준혁](https://github.com/tree-jhk)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [안지완](https://github.com/synoti21)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [오효근](https://github.com/Zerohertz)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

처음에는 정렬 혹은 `heapq`를 사용하나 싶었지만 순서가 중요한 문제이기 때문에 `list` 혹은 `deque`을 사용해야한다고 생각했다.
현재 `deque`의 마지막 값보다 큰 입력이 입력되면 `append`, 작은 입력이 입력되면 `pop`을 사용하는 것으로 생각했다.

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

문제에서 `x`는 사용하지 않기에 버려준다. (어차피 순서대로 들어오기 때문)
접근법에서 언급한 것과 같이 아래와 같이 구현하면 끝이다.

```python
while 1 < len(height) and y < height[-1]:
    height.pop()
    cnt += 1
if not height[-1] == y:
    height.append(y)
```

시간 복잡도는 `O(n)`이다.

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

무난한 문제였지만 처음 풀이에서 `while`문을 당연히 안쓸거라는 선입견에 생각보다 시간이 걸렸다.

## Solution

<!--전체 코드 첨부-->

```python
import sys

read = sys.stdin.readline

if __name__ == "__main__":
    n = int(read())
    cnt = 0
    height = [0]
    for i in range(n + 2):
        if i in [0, n + 1]:
            x, y = 0, 0
        else:
            x, y = map(int, read().split())
        while 1 < len(height) and y < height[-1]:
            height.pop()
            cnt += 1
        if not height[-1] == y:
            height.append(y)
    print(cnt)
```

---

# [조은학](https://github.com/choeunhak)

## 접근법 (생각의 흐름 설명)
<!--문제를 풀며 생각의 흐름을 글로 작성-->
- 처음엔 잘못 풀었다.
- 처음에는 집합 자료구조로 0으로 구분해서 12131, 2321 로 묶어서 각각 집합으로 처리해 123, 123 총 6개로 답을 도출했다.
- 하지만 반례로, 22114422 이런식으로 되어 있을 경우에는 4개가 필요하기 때문에 문제가 있는 풀이다.

잘못된 풀이
```python
import sys

n = int(sys.stdin.readline().strip())
buildings = []
tmp = []
for i in range(n):
    # print(buildings)
    x, y = map(int, input().split())
    if(y!=0):
        tmp.append(y)
    else:
        buildings.append(set(tmp))
        tmp=[]

buildings.append(set(tmp))

answer = 0
for i in range(len(buildings)):
    answer += len(buildings[i])
# print(buildings)
print(answer)
```

- 따라서 다시 생각하다보니 스택으로 풀어야겠다는 생각을 하게 되었다.


## 상세한 해설
<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

- while( stack and (buildings[i] < stack[-1])):: 
스택이 비어있지 않고 현재 건물의 높이가 스택의 맨 위 건물보다 작은 경우 반복

- stack.pop(): 
answer += 1: 
answer를 더해주면서 스택의 건물 제거

- if(stack and (buildings[i] == stack[-1])):: 
스택이 비어있지 않고 현재 건물의 높이가 스택의 맨 위 건물과 같은 경우 continue

- stack.append(buildings[i]): 
현재 건물을 스택에 추가 (스택의 맨위 건물과 같은 경우에는 추가 안함)


- 마지막 while 문에서 0일 경우를 제외시켜줘야 한다.

- 최악일 경우 O(n^2)이라고 생각한다.

## 회고
<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution
<!--전체 코드 첨부-->

```python
import sys

n = int(sys.stdin.readline().strip())
stack = []
buildings = []
answer = 0
for i in range(n):
    x, y = map(int, input().split())
    buildings.append(y)

stack.append(buildings[0])

for i in range(1,len(buildings)):
    while( stack and (buildings[i] < stack[-1])):
        stack.pop()
        answer += 1
    if(stack and (buildings[i] == stack[-1])):
        continue
    stack.append(buildings[i])

while(stack):
    if(stack[-1]>0):
        answer += 1
    stack.pop()

print(answer)
```
