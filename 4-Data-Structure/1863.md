# Index

+ [권준혁](#권준혁)
+ [안지완](#안지완)
+ [오효근](#오효근)
+ [조은학](#조은학)

---

# [스카이라인 쉬운거](https://www.acmicpc.net/problem/1863)

도시에서 태양이 질 때에 보이는 건물들의 윤곽을 스카이라인이라고 한다. 스카이라인만을 보고서 도시에 세워진 건물이 몇 채인지 알아 낼 수 있을까? 건물은 모두 직사각형 모양으로 밋밋하게 생겼다고 가정한다.

정확히 건물이 몇 개 있는지 알아내는 것은 대부분의 경우에 불가능하고, 건물이 최소한 몇 채 인지 알아내는 것은 가능해 보인다. 이를 알아내는 프로그램을 작성해 보자.

## 입력

첫째 줄에 n이 주어진다. (1 ≤ n ≤ 50,000) 다음 n개의 줄에는 왼쪽부터 스카이라인을 보아 갈 때 스카이라인의 고도가 바뀌는 지점의 좌표 x와 y가 주어진다. (1 ≤ x ≤ 1,000,000. 0 ≤ y ≤ 500,000) 첫 번째 지점의 x좌표는 항상 1이다.

## 출력

첫 줄에 최소 건물 개수를 출력한다.

## 예제

> 입력 1

```
10
1 1
2 2
5 1
6 3
8 1
11 0
15 2
17 3
20 2
22 1
```

> 출력 1

```
6
```

---

# [권준혁](https://github.com/tree-jhk)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [안지완](https://github.com/synoti21)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [오효근](https://github.com/Zerohertz)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

처음에는 정렬 혹은 `heapq`를 사용하나 싶었지만 순서가 중요한 문제이기 때문에 `list` 혹은 `deque`을 사용해야한다고 생각했다.
현재 `deque`의 마지막 값보다 큰 입력이 입력되면 `append`, 작은 입력이 입력되면 `pop`을 사용하는 것으로 생각했다.

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

문제에서 `x`는 사용하지 않기에 버려준다. (어차피 순서대로 들어오기 때문)
접근법에서 언급한 것과 같이 아래와 같이 구현하면 끝이다.

```python
while 1 < len(height) and y < height[-1]:
    height.pop()
    cnt += 1
if not height[-1] == y:
    height.append(y)
```

시간 복잡도는 `O(n)`이다.

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

무난한 문제였지만 처음 풀이에서 `while`문을 당연히 안쓸거라는 선입견에 생각보다 시간이 걸렸다.

## Solution

<!--전체 코드 첨부-->

```python
import sys

read = sys.stdin.readline

if __name__ == "__main__":
    n = int(read())
    cnt = 0
    height = [0]
    for i in range(n + 2):
        if i in [0, n + 1]:
            x, y = 0, 0
        else:
            x, y = map(int, read().split())
        while 1 < len(height) and y < height[-1]:
            height.pop()
            cnt += 1
        if not height[-1] == y:
            height.append(y)
    print(cnt)
```

---

# [조은학](https://github.com/choeunhak)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```
