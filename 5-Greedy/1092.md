# Index

+ [권준혁](#권준혁)
+ [안지완](#안지완)
+ [오효근](#오효근)
+ [조은학](#조은학)

---

# [배](https://www.acmicpc.net/problem/1092)

지민이는 항구에서 일한다. 그리고 화물을 배에 실어야 한다. 모든 화물은 박스에 안에 넣어져 있다. 항구에는 크레인이 N대 있고, 1분에 박스를 하나씩 배에 실을 수 있다. 모든 크레인은 동시에 움직인다.

각 크레인은 무게 제한이 있다. 이 무게 제한보다 무거운 박스는 크레인으로 움직일 수 없다. 모든 박스를 배로 옮기는데 드는 시간의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 크레인의 무게 제한이 주어진다. 이 값은 1,000,000보다 작거나 같다. 셋째 줄에는 박스의 수 M이 주어진다. M은 10,000보다 작거나 같은 자연수이다. 넷째 줄에는 각 박스의 무게가 주어진다. 이 값도 1,000,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 모든 박스를 배로 옮기는데 드는 시간의 최솟값을 출력한다. 만약 모든 박스를 배로 옮길 수 없으면 -1을 출력한다.

## 예제

> 입력 1

```
3
6 8 9
5
2 5 2 4 7
```

> 출력 1

```
2
```

> 입력 2

```
2
19 20
7
14 12 16 19 16 1 5
```

> 출력 2

```
4
```

> 입력 3

```
4
23 32 25 28
10
5 27 10 16 24 20 2 32 18 7
```

> 출력 3

```
3
```

> 입력 4

```
10
11 17 5 2 20 7 5 5 20 7
5
18 18 15 15 17
```

> 출력 4

```
2
```

---

# [권준혁](https://github.com/tree-jhk)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [안지완](https://github.com/synoti21)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

각 크레인이 자신이 들 수 있는 최대한 무거운 박스들을 옮긴다면, 옮기는 시간은 자연스럽게 최소가 될 것이라는 생각을 착안하여 구성했다.

따라서, 우선 크레인과 박스들을 내림차순으로 정렬을 한 후, 각 크레인마다 최대한 무거운 박스를 배정했다.
## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

```python
n = int(input())
cranes = list(map(int, input().split()))
m = int(input())
boxes = list(map(int, input().split()))

# Tim Sort
cranes.sort(reverse=True)
boxes.sort(reverse=True)
```
`Python`에서는 기본 `sort()` 알고리즘이 `Tim Sort` 알고리즘을 채택하는 것으로 알려져있다.

`Tim Sort`는 `Insertion Sort`와 `Merge Sort`를 결합한 정렬 알고리즘으로, 인접한 메모리와의 비교를 이용한 `Insertion Sort`가 범위가 적으면 적을 수록 빠르다는 점을 이용하여, `Merge Sort`로 전체 데이터들을 분할한 다음, `Insertion Sort`로 이를 비교하는 기법이다.

따라서, `O(nlogn * mlogm)`의 시간 복잡도를 가지고 있다.

```python
while boxes:
    for crane in cranes:
        for box in boxes:
            if crane >= box:
                boxes.remove(box)
                break
    ans += 1
```
이 부분에서는 크레인 별로 가장 무거운 박스를 배정받기 위해 다음과 같이 각 크레인 별로 가장 무거운 상자를 싣기 위해, 다음과 같이 조건문을 생성했다.

문제는, 이 경우 시간복잡도가 더욱 증가한다. `boxes.remove(box)`의 경우, 전체 배열을 스캔하여 가장 처음으로 나온 원소를 스캔한다. 즉, `O(m)`만큼의 시간복잡도가 증가한다.

따라서, 위의 loop은 결과적으로 `O(nlogn * n) = O(n^2logn)`만큼의 시간복잡도가 걸린다.

위의 문제는 이렇게 될 것이다. 반복문이 `O(n*m)`이므로,

`O(n*m^2logm)`이 될 것이다. 문제를 풀 긴 했으나, 상당히 시간이 걸리는 작업이다.

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->
좀 더 시간복잡도를 줄일 수 있는 방법을 찾으면 좋을 것 같다.
## Solution

<!--전체 코드 첨부-->

```python
import sys

input = sys.stdin.readline

n = int(input())
cranes = list(map(int, input().split()))
m = int(input())
boxes = list(map(int, input().split()))

# Tim Sort
cranes.sort(reverse=True)
boxes.sort(reverse=True)

ans = 0

if boxes[0] > cranes[0]:
    print(-1)
    exit()

while boxes:
    for crane in cranes:
        for box in boxes:
            if crane >= box:
                boxes.remove(box)
                break
    ans += 1

print(ans)
```

---

# [오효근](https://github.com/Zerohertz)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```

---

# [조은학](https://github.com/choeunhak)

## 접근법 (생각의 흐름 설명)

<!--문제를 풀며 생각의 흐름을 글로 작성-->

## 상세한 해설

<!--기술 면접을 면접관 앞에서 한다는 생각으로 설명-->
<!--시복도, 알고리즘 선택 이유 등-->

## 회고

<!--이런 유형은 이렇게 접근하면 좋겠다 (이유와 함께)-->

## Solution

<!--전체 코드 첨부-->

```python

```
